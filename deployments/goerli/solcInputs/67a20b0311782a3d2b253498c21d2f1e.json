{
  "language": "Solidity",
  "sources": {
    "contracts/SportsBetting.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.12;\r\n\r\n//import \"./mock/IERC20.sol\";\r\nimport \"./SportsOracleConsumer.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./SportsBettingLib.sol\";\r\n\r\n/// @title A contract for sports result staking\r\n/// @author Nathan Cinnamond\r\n/// @notice Handles user stakes and allows winning stakers to claim payouts \r\ncontract SportsBetting is SportsOracleConsumer {\r\n\r\n    enum BettingState {\r\n        CLOSED,\r\n        OPENING,\r\n        OPEN,\r\n        AWAITING,\r\n        PAYABLE,\r\n        CANCELLED\r\n    }\r\n\r\n    struct FixtureEnrichment {\r\n        BettingState fixtureState;\r\n        uint256[3] total;\r\n        uint256[3] user;\r\n    }\r\n\r\n    /// @notice Event emitted each time the betting state for a fixture changes\r\n    /// @param fixtureID: the corresponding fixtureID for fixture that has state change\r\n    /// @param state: the BettingState corresponding to the new state of the fixture\r\n    event BettingStateChanged(string fixtureID, BettingState state);\r\n\r\n    /// @notice Event emitted each time a user stakes on a fixture outcome\r\n    /// @param better: address of the staker\r\n    /// @param fixtureID: corresponding fixtureID for fixture on which outcome is staked\r\n    /// @param amount: amount added to total amount staked by better on fixture outcome\r\n    /// @param betType: outcome of fixtureID that better has staked on\r\n    event BetStaked(\r\n        address indexed better,\r\n        string fixtureID,\r\n        uint256 amount,\r\n        SportsBettingLib.FixtureResult betType\r\n    );\r\n\r\n    /// @notice Event emitted each time a user unstakes on a fixture outcome\r\n    /// @param better: address of the unstaker\r\n    /// @param fixtureID: corresponding fixtureID for fixture on which outcome is unstaked\r\n    /// @param amount: amount subtracted from total amount staked by better on fixture outcome\r\n    /// @param betType: outcome of fixtureID that better has unstaked on\r\n    event BetUnstaked(\r\n        address indexed better,\r\n        string fixtureID,\r\n        uint256 amount,\r\n        SportsBettingLib.FixtureResult betType\r\n    );\r\n\r\n    /// @notice Event emitted each time a user claims payout on fixture result\r\n    /// @param better: address of the unstaker\r\n    /// @param fixtureID: corresponding fixtureID for fixture on outcome which better claims payout\r\n    /// @param amount: amount paid out to better (original stake plus profit)\r\n    event BetPayout(address indexed better, string fixtureID, uint256 amount);\r\n\r\n    /// @notice Event emitted each time owner claims commission on bet payout profits\r\n    /// @param amount: amount paid out to owner in commission\r\n    event BetCommissionPayout(string indexed fixtureID, uint256 amount);\r\n\r\n    /// @notice Event emitted each time a fixture kickoff time is fulfilled by oracle\r\n    /// @param fixtureID: corresponding fixtureID for fixture with kickoff time fulfilled\r\n    /// @param kickoffTime: unix timestamp of kickoff time for fixture\r\n    event KickoffTimeUpdated(string fixtureID, uint256 kickoffTime);\r\n\r\n    SportsBettingLib.FixtureResult[5] public betTypes;\r\n\r\n    // Contract owner\r\n    address public immutable owner;\r\n\r\n    // DAI Stablecoin address\r\n    address public immutable daiAddress;\r\n\r\n    // Entrance fee of 0.0001 DAI (10^14 Wei)\r\n    uint256 public constant ENTRANCE_FEE = 10e14;\r\n\r\n    // Commission rate percentage taken by contract owner for each payout as a percentage\r\n    uint256 public constant COMMISSION_RATE = 1;\r\n\r\n    // Max time before a fixture kick-off that a bet can be placed in seconds\r\n    // A fixture bet state will not move to OPEN before a time to the left of the\r\n    // ko time equal to BET_ADVANCE_TIME\r\n    uint256 public constant BET_ADVANCE_TIME = 7 days; // 7 days\r\n\r\n    // Cut off time for bets before KO time in seconds\r\n    // i.e. all bets must be placed at time t where t < koTime - BET_CUTOFF_TIME\r\n    uint256 public constant BET_CUTOFF_TIME = 90 minutes; // 90 minutes\r\n\r\n    // Map each fixture ID to whether betting is open for this fixture\r\n    mapping(string => BettingState) public bettingState;\r\n\r\n    // Map each fixture ID to a map of FixtureResult to a map of address to uint representing the amount of wei bet on that result\r\n    mapping(string => mapping(SportsBettingLib.FixtureResult => mapping(address => uint256)))\r\n        public amounts;\r\n\r\n    // Map each fixture ID to a map of FixtureResult to a uint representing the total amount of wei bet on that result\r\n    mapping(string => mapping(SportsBettingLib.FixtureResult => uint256))\r\n        public totalAmounts;\r\n\r\n    // Map each fixture ID to a map of address to amount the ctx paid the address owner for that fixture\r\n    mapping(string => mapping(address => uint256)) public payouts;\r\n\r\n    // Map each user address to fixture ID to boolean representing whether they were paid for a fixture\r\n    mapping(string => mapping(address => bool)) public userWasPaid;\r\n\r\n    // Map oracle request ID for fixture kickoff time request to corresponding fixture ID\r\n    mapping(bytes32 => string) public requestKickoffToFixture;\r\n\r\n    // Map each fixture ID to unix timestamp for its kickoff time\r\n    mapping(string => uint256) public fixtureToKickoffTime;\r\n\r\n    // Map oracle request ID for fixture result request to corresponding fixture ID\r\n    mapping(bytes32 => string) public requestResultToFixture;\r\n\r\n    // Map fixture ID to fixture result\r\n    mapping(string => SportsBettingLib.FixtureResult) public results;\r\n\r\n    // Commission total taken by contract owner indexed by fixture\r\n    mapping(string => uint256) public commissionMap;\r\n\r\n    // Map of fixture ID to whether commission was paid to owner for this fixture\r\n    mapping(string => bool) public commissionPaid;\r\n\r\n    constructor(\r\n        string memory _sportsOracleURI,\r\n        address _oracle,\r\n        address _dai,\r\n        address _link,\r\n        string memory _jobId,\r\n        uint256 _fee\r\n    ) SportsOracleConsumer(_sportsOracleURI, _oracle, _link, _jobId, _fee) {\r\n        betTypes[0] = SportsBettingLib.FixtureResult.DEFAULT;\r\n        betTypes[1] = SportsBettingLib.FixtureResult.CANCELLED;\r\n        betTypes[2] = SportsBettingLib.FixtureResult.HOME;\r\n        betTypes[3] = SportsBettingLib.FixtureResult.DRAW;\r\n        betTypes[4] = SportsBettingLib.FixtureResult.AWAY;\r\n\r\n        owner = msg.sender;\r\n        daiAddress = _dai;\r\n    }\r\n\r\n    // Wrapper for setting fixture betting state and emitting event\r\n    function setFixtureBettingState(string memory fixtureID, BettingState state)\r\n        internal\r\n    {\r\n        bettingState[fixtureID] = state;\r\n        emit BettingStateChanged(fixtureID, state);\r\n    }\r\n\r\n    /// @notice Closes fixture if it is 1. Not currently closed AND 2. eligible to be closed\r\n    /// @param fixtureID: the corresponding fixtureID for fixture to be closed\r\n    function closeBetForFixture(string memory fixtureID) public {\r\n        require(\r\n            bettingState[fixtureID] != BettingState.CLOSED,\r\n            \"Bet state is already CLOSED.\"\r\n        );\r\n        require(\r\n            fixtureShouldBecomeClosed(fixtureID),\r\n            \"Fixture ineligible to be closed.\"\r\n        );\r\n        setFixtureBettingState(fixtureID, BettingState.CLOSED);\r\n    }\r\n\r\n    /// @notice Makes oracle request to get fixture kickoff time and set fixture state to OPENING\r\n    /// @notice On fulfillment handle, ctx will open fixture is eligible\r\n    /// @param fixtureID: the corresponding fixtureID for fixture to be opened\r\n    function openBetForFixture(string memory fixtureID) public {\r\n        require(\r\n            bettingState[fixtureID] == BettingState.CLOSED || bettingState[fixtureID] == BettingState.OPENING,\r\n            \"State must be CLOSED or OPENING.\"\r\n        );\r\n        setFixtureBettingState(fixtureID, BettingState.OPENING);\r\n        requestFixtureKickoffTime(fixtureID);\r\n    }\r\n    \r\n    /// @notice Changes fixture betting state to AWAITING if eligible\r\n    /// @param fixtureID: the corresponding fixtureID for fixture to be set to AWAITING\r\n    function awaitBetForFixture(string memory fixtureID) public {\r\n        // Ideally the betting state will change from OPEN -> AWAITING\r\n        // by virtue of a bet being placed too close to KO time, however\r\n        // in the event this doesn't happen, this function can be called to\r\n        // attempt to change state to AWAITING\r\n        require(\r\n            bettingState[fixtureID] == BettingState.OPEN,\r\n            \"Bet state must be OPEN.\"\r\n        );\r\n        require(\r\n            fixtureShouldBecomeAwaiting(fixtureID),\r\n            \"Fixture ineligible for AWAITING.\"\r\n        );\r\n        setFixtureBettingState(fixtureID, BettingState.AWAITING);\r\n    }\r\n\r\n    function fixtureShouldBecomeAwaiting(string memory fixtureID) internal view returns(bool) {\r\n        uint256 ko = fixtureToKickoffTime[fixtureID];\r\n        // OPEN -> AWAITING\r\n        // If a bet is OPEN, it becomes AWAITING if\r\n        // current time is more than BET_CUTOFF_TIME to the right of kickoff time\r\n        return (\r\n            ko > BET_CUTOFF_TIME &&\r\n            bettingState[fixtureID] == BettingState.OPEN &&\r\n            block.timestamp > ko - BET_CUTOFF_TIME\r\n        );\r\n    }\r\n\r\n    function fixtureShouldBecomeOpen(string memory fixtureID) internal view returns(bool) {\r\n        uint256 ko = fixtureToKickoffTime[fixtureID];\r\n        // OPENING -> OPEN\r\n        // If a bet is OPENING, it can be OPENed if\r\n        // current time is more than BET_CUTOFF_TIME before kickoff time AND\r\n        // current time is less than BET_ADVANCE_TIME before kickoff time\r\n        return (\r\n            ko != 0 &&\r\n            ko >= BET_CUTOFF_TIME &&\r\n            ko >= BET_ADVANCE_TIME &&\r\n            (\r\n                bettingState[fixtureID] == BettingState.OPENING &&\r\n                block.timestamp <= ko - BET_CUTOFF_TIME &&\r\n                block.timestamp >= ko - BET_ADVANCE_TIME\r\n            )\r\n        );\r\n    }\r\n\r\n    function fixtureShouldBecomeClosed(string memory fixtureID) internal view returns(bool) {\r\n        uint256 ko = fixtureToKickoffTime[fixtureID];\r\n        return (\r\n            // OPENING -> CLOSED\r\n            // If fixture is OPENING, it will become CLOSED if\r\n            // current time is to the right of kickoff time - BET_CUTOFF_TIME\r\n            // OR\r\n            // current time is to the left of kickoff time - BET_ADVANCE_TIME\r\n            bettingState[fixtureID] == BettingState.OPENING &&\r\n            ko != 0 &&\r\n            ko >= BET_CUTOFF_TIME &&\r\n            ko >= BET_ADVANCE_TIME &&\r\n            (block.timestamp > ko - BET_CUTOFF_TIME ||\r\n                block.timestamp < ko - BET_ADVANCE_TIME)\r\n        );\r\n    }\r\n\r\n    /// @notice Allows user to stake on fixture with ID fixtureID for outcome 'betType' with 'amount'\r\n    /// @param fixtureID: Corresponding fixtureID for fixture user is staking on\r\n    /// @param betType: The fixture outcome the msg sender is staking on\r\n    /// @param amount: The amount of collateral added to user's total stake on fixture outcome\r\n    function stake(\r\n        string memory fixtureID, \r\n        SportsBettingLib.FixtureResult betType, \r\n        uint256 amount) \r\n    public {\r\n        // Don't allow stakes if we should be in AWAITING state\r\n        if (fixtureShouldBecomeAwaiting(fixtureID)) {\r\n            setFixtureBettingState(fixtureID, BettingState.AWAITING);\r\n            return;\r\n        }\r\n\r\n        // Impose requirements\r\n        require(\r\n            betType != SportsBettingLib.FixtureResult.DEFAULT && \r\n            betType != SportsBettingLib.FixtureResult.CANCELLED, \r\n            \"This BetType is not permitted.\");\r\n        require(bettingState[fixtureID] == BettingState.OPEN, \"Bet activity is not open.\");\r\n        require(amount >= ENTRANCE_FEE, \"Amount is below entrance fee.\");\r\n\r\n        bool flag;\r\n        uint256 newStakerAmount;\r\n        uint256 newTotalAmount;\r\n\r\n        // Handle possible overflow on staker amount\r\n        (flag, newStakerAmount) = SafeMath.tryAdd(amounts[fixtureID][betType][msg.sender], amount);\r\n        require(flag, \"User stake overflow.\");\r\n\r\n        // Handle possible overflow on total amounts\r\n        (flag, newTotalAmount) = SafeMath.tryAdd(totalAmounts[fixtureID][betType], amount);\r\n        require(flag, \"Total stake overflow.\");\r\n\r\n        // Update state\r\n        amounts[fixtureID][betType][msg.sender] = newStakerAmount;\r\n        totalAmounts[fixtureID][betType] = newTotalAmount;\r\n\r\n        // Transfer DAI tokens\r\n        emit BetStaked(msg.sender, fixtureID, amount, betType);\r\n        IERC20 dai = IERC20(daiAddress);\r\n        require(\r\n            dai.transferFrom(msg.sender, address(this), amount),\r\n            \"Unable to transfer.\"\r\n        );\r\n    }\r\n\r\n    /// @notice Allows user to unstake on fixture with ID fixtureID for outcome 'betType' with 'amount'\r\n    /// @param fixtureID: Corresponding fixtureID for fixture user is unstaking on\r\n    /// @param betType: The fixture outcome the msg sender is unstaking on\r\n    /// @param amount: The amount of collateral subtracted from user's total stake on fixture outcome\r\n    function unstake(\r\n        string memory fixtureID,\r\n        SportsBettingLib.FixtureResult betType,\r\n        uint256 amount\r\n    ) public {\r\n        // Don't allow stakes if we should be in AWAITING state\r\n        if (fixtureShouldBecomeAwaiting(fixtureID)) {\r\n            setFixtureBettingState(fixtureID, BettingState.AWAITING);\r\n            return;\r\n        }\r\n\r\n        // Betting must be in OPEN state for this fixture\r\n        require(bettingState[fixtureID] == BettingState.OPEN, \"Bet activity is not open.\");\r\n\r\n        // Impose requirements on unstake value\r\n        require(amount > 0, \"Amount should exceed zero.\");\r\n\r\n        // Impose requirements on user's stake if this unstake occurs\r\n        uint256 amountStaked = amounts[fixtureID][betType][msg.sender];\r\n        require(amountStaked > 0, \"No stake on this address-result.\");\r\n        require(amount <= amountStaked, \"Current stake too low.\");\r\n\r\n        // New value for user stake on this fixture-betType combo\r\n        uint256 newStakerAmount = amountStaked - amount;\r\n\r\n        // If this is a partial unstake, ensure ENTRANCE_FEE is maintained\r\n        if (newStakerAmount > 0) {\r\n            require(newStakerAmount >= ENTRANCE_FEE, \"Cannot go below entrance fee.\");\r\n        }\r\n\r\n        // Update state\r\n        amounts[fixtureID][betType][msg.sender] = newStakerAmount;\r\n        totalAmounts[fixtureID][betType] -= amount;\r\n\r\n        // Transfer DAI to msg sender\r\n        emit BetUnstaked(msg.sender, fixtureID, amount, betType);\r\n        IERC20 dai = IERC20(daiAddress);\r\n        require(dai.transfer(msg.sender, amount), \"Unable to transfer DAI.\");\r\n    }\r\n\r\n    /// @notice Calls consumer contract to request fixture kickoff time from oracle\r\n    /// @param fixtureID: Corresponding fixtureID for fixture user requests kickoff time for\r\n    function requestFixtureKickoffTime(string memory fixtureID) public {\r\n        bytes32 requestID = requestFixtureKickoffTimeParameter(fixtureID);\r\n        requestKickoffToFixture[requestID] = fixtureID;\r\n        emit RequestedFixtureKickoff(requestID, fixtureID);\r\n    }\r\n\r\n    function fulfillFixtureKickoffTime(bytes32 requestId, uint256 ko)\r\n        internal\r\n        override\r\n    {\r\n        string memory fixtureID = requestKickoffToFixture[requestId];\r\n        if (bytes(fixtureID).length == 0) {\r\n            revert(\"No fixture matches request ID.\");\r\n        }\r\n        emit RequestFixtureKickoffFulfilled(requestId, fixtureID, ko);\r\n\r\n        updateKickoffTime(fixtureID, ko);\r\n        if (fixtureShouldBecomeOpen(fixtureID)) {\r\n            setFixtureBettingState(fixtureID, BettingState.OPEN);\r\n        } else if (fixtureShouldBecomeClosed(fixtureID)) {\r\n            setFixtureBettingState(fixtureID, BettingState.CLOSED);\r\n        }\r\n    }\r\n\r\n    function updateKickoffTime(string memory fixtureID, uint256 ko) internal {\r\n        if (ko != fixtureToKickoffTime[fixtureID]) {\r\n            fixtureToKickoffTime[fixtureID] = ko;\r\n            emit KickoffTimeUpdated(fixtureID, ko);\r\n        }\r\n    }\r\n\r\n    /// @notice Calls consumer contract to request fixture result from oracle\r\n    /// @param fixtureID: Corresponding fixtureID for fixture user requests result for\r\n    function requestFixtureResult(string memory fixtureID) public {\r\n        bytes32 requestID = requestFixtureResultParameter(fixtureID);\r\n        requestResultToFixture[requestID] = fixtureID;\r\n        emit RequestedFixtureResult(requestID, fixtureID);\r\n    }\r\n\r\n    function fulfillFixtureResult(bytes32 requestId, uint256 result)\r\n        internal\r\n        override\r\n    {\r\n        string memory fixtureID = requestResultToFixture[requestId];\r\n        // Can't proceed with empty fixture ID\r\n        if (bytes(fixtureID).length == 0) {\r\n            revert(\"Cannot find fixture ID\");\r\n        }\r\n\r\n        emit RequestFixtureResultFulfilled(requestId, fixtureID, result);\r\n\r\n        SportsBettingLib.FixtureResult parsedResult = SportsBettingLib.getFixtureResultFromAPIResponse(result);\r\n        if (parsedResult == SportsBettingLib.FixtureResult.DEFAULT) {\r\n            string memory errorString = string.concat(\r\n                \"Error on fixture \",\r\n                fixtureID,\r\n                \": Unknown fixture result from API\"\r\n            );\r\n            revert(errorString);\r\n        }\r\n\r\n        results[fixtureID] = parsedResult;\r\n\r\n        // Only action on fixture result if we are in AWAITING\r\n        if (bettingState[fixtureID] == BettingState.AWAITING) {\r\n            if (parsedResult == SportsBettingLib.FixtureResult.CANCELLED) {\r\n                setFixtureBettingState(fixtureID, BettingState.CANCELLED);\r\n            } else {\r\n                setFixtureBettingState(fixtureID, BettingState.PAYABLE);\r\n            } \r\n        }\r\n    }\r\n\r\n    /// @notice Transfers user winnings on fixture if applicable\r\n    /// @param fixtureID: Corresponding fixtureID for fixture user withdraws winnings for\r\n    function withdrawPayout(string memory fixtureID)\r\n        public\r\n    {\r\n        require(\r\n            bettingState[fixtureID] == BettingState.PAYABLE || bettingState[fixtureID] == BettingState.CANCELLED,\r\n            \"State not PAYABLE or CANCELLED.\"\r\n        );\r\n\r\n        // Require user has not received payout for this fixture\r\n        require(!userWasPaid[fixtureID][msg.sender], \"Already paid.\");\r\n\r\n        if (bettingState[fixtureID] == BettingState.PAYABLE) {\r\n            handleWithdrawPayout(fixtureID);\r\n        } else if (bettingState[fixtureID] == BettingState.CANCELLED) {\r\n            handleFixtureCancelledPayout(fixtureID);\r\n        }\r\n    }\r\n\r\n    function handleWithdrawPayout(string memory fixtureID)\r\n        internal\r\n    {\r\n        SportsBettingLib.FixtureResult result = results[fixtureID];\r\n        if (result == SportsBettingLib.FixtureResult.DEFAULT || result == SportsBettingLib.FixtureResult.CANCELLED) {\r\n            revert(\"Invalid fixture result.\");\r\n        }\r\n\r\n        // Require user had staked on winning result\r\n        uint256 stakerAmount = amounts[fixtureID][result][msg.sender];\r\n        require(stakerAmount > 0, \"You did not stake on the winning outcome\");\r\n\r\n        SportsBettingLib.FixtureResult[] memory winningOutcomes = new SportsBettingLib.FixtureResult[](1);\r\n        winningOutcomes[0] = result;\r\n        SportsBettingLib.FixtureResult[] memory losingOutcomes = SportsBettingLib.getLosingFixtureOutcomes(result);\r\n        // Get total amounts bet on each fixture result\r\n        uint256 winningAmount = getTotalAmountBetOnFixtureOutcomes(fixtureID, winningOutcomes);\r\n        uint256 losingAmount = getTotalAmountBetOnFixtureOutcomes(fixtureID, losingOutcomes);\r\n        (bool flag, uint256 totalAmount) = SafeMath.tryAdd(winningAmount, losingAmount);\r\n        if (!flag) {\r\n            revert(\"Overflow on total amount bet\");\r\n        }\r\n\r\n        // Calculate staker's share of winnings\r\n        uint256 obligation = SportsBettingLib.calculateStakerObligation(stakerAmount, winningAmount, totalAmount);\r\n        // Deduct owner commission\r\n        // Commission of COMMISSION_RATE % is taken from staker profits\r\n        uint256 commission = SportsBettingLib.calculateCommission(obligation, stakerAmount, COMMISSION_RATE);\r\n        obligation -= commission;\r\n\r\n        // Set bet payout states\r\n        payouts[fixtureID][msg.sender] = obligation;\r\n        userWasPaid[fixtureID][msg.sender] = true;\r\n\r\n        // Pay staker\r\n        emit BetPayout(msg.sender, fixtureID, obligation);\r\n        IERC20 dai = IERC20(daiAddress);\r\n        require(\r\n            dai.transfer(msg.sender, obligation),\r\n            \"Unable to payout staker\"\r\n        );\r\n    }\r\n\r\n    function handleFixtureCancelledPayout(string memory fixtureID)\r\n        internal\r\n    {\r\n        require(bettingState[fixtureID] == BettingState.CANCELLED, \"Fixture not cancelled\");\r\n        uint256 obligation = 0;\r\n        for (uint256 i = 0; i < betTypes.length; i++) {\r\n            obligation += amounts[fixtureID][betTypes[i]][msg.sender];\r\n        }\r\n        require(obligation > 0, \"No stakes found on this fixture\");\r\n\r\n        // Set bet payout states\r\n        payouts[fixtureID][msg.sender] = obligation;\r\n        userWasPaid[fixtureID][msg.sender] = true;\r\n\r\n        // Pay staker\r\n        emit BetPayout(msg.sender, fixtureID, obligation);\r\n        IERC20 dai = IERC20(daiAddress);\r\n        require(\r\n            dai.transfer(msg.sender, obligation),\r\n            \"Unable to payout staker\"\r\n        );\r\n    }\r\n\r\n    /// @notice Transfers owner commission on fixture if applicable\r\n    /// @param fixtureID: Corresponding fixtureID for fixture owner withdraws commission for\r\n    function handleCommissionPayout(string memory fixtureID) public {\r\n        require(bettingState[fixtureID] == BettingState.PAYABLE, \"Fixture not payable\");\r\n        require(!commissionPaid[fixtureID], \"Commission already paid.\");\r\n\r\n        SportsBettingLib.FixtureResult result = results[fixtureID];\r\n        if (result == SportsBettingLib.FixtureResult.DEFAULT || result == SportsBettingLib.FixtureResult.CANCELLED) {\r\n            revert(\"Invalid fixture result.\");\r\n        }\r\n\r\n        // Commission of COMMISSION RATE % is taken from total staker profits\r\n        SportsBettingLib.FixtureResult[] memory winningOutcomes = new SportsBettingLib.FixtureResult[](1);\r\n        winningOutcomes[0] = result;\r\n        uint256 winningAmount = getTotalAmountBetOnFixtureOutcomes(fixtureID, winningOutcomes);\r\n\r\n        SportsBettingLib.FixtureResult[] memory losingOutcomes = SportsBettingLib.getLosingFixtureOutcomes(result);\r\n        uint256 losingAmount = getTotalAmountBetOnFixtureOutcomes(fixtureID, losingOutcomes);\r\n        \r\n        uint256 totalAmount = winningAmount + losingAmount;\r\n\r\n        // Calculate commission\r\n        uint256 commission = SportsBettingLib.calculateCommission(totalAmount, winningAmount, COMMISSION_RATE);\r\n\r\n        // Set commissionPaid to prevent re-entrancy\r\n        commissionMap[fixtureID] = commission;\r\n        commissionPaid[fixtureID] = true;\r\n\r\n        emit BetCommissionPayout(fixtureID, commissionMap[fixtureID]);\r\n        if (commissionMap[fixtureID] > 0) {\r\n            IERC20 dai = IERC20(daiAddress);\r\n            require(\r\n                dai.transfer(owner, commissionMap[fixtureID]),\r\n                \"Unable to payout owner\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function getTotalAmountBetOnFixtureOutcomes(\r\n        string memory fixtureID,\r\n        SportsBettingLib.FixtureResult[] memory outcomes\r\n    ) internal view returns (uint256) {\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < outcomes.length; i++) {\r\n            amount += totalAmounts[fixtureID][outcomes[i]];\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /// @notice Gets total and user stakes on all outcomes for fixture\r\n    /// @param fixtureID: Corresponding fixtureID for fixture outcomes\r\n    /// @param user: Address of user corresponding to user fixture stakes\r\n    /// @return FixtureEnrichment struct containing fixture state, user stakes and total stakes\r\n    function getEnrichedFixtureData(string memory fixtureID, address user)\r\n        public\r\n        view\r\n        returns (FixtureEnrichment memory)\r\n    {\r\n        return\r\n            FixtureEnrichment({\r\n                fixtureState: bettingState[fixtureID],\r\n                user: getStakeSummaryForUser(fixtureID, user),\r\n                total: [\r\n                    totalAmounts[fixtureID][SportsBettingLib.FixtureResult.HOME],\r\n                    totalAmounts[fixtureID][SportsBettingLib.FixtureResult.DRAW],\r\n                    totalAmounts[fixtureID][SportsBettingLib.FixtureResult.AWAY]\r\n                ]\r\n            });\r\n    }\r\n\r\n    function getStakeSummaryForUser(string memory fixtureID, address user)\r\n        internal\r\n        view\r\n        returns (uint256[3] memory)\r\n    {\r\n        return [\r\n            amounts[fixtureID][SportsBettingLib.FixtureResult.HOME][user],\r\n            amounts[fixtureID][SportsBettingLib.FixtureResult.DRAW][user],\r\n            amounts[fixtureID][SportsBettingLib.FixtureResult.AWAY][user]\r\n        ];\r\n    }\r\n}\r\n"
    },
    "contracts/SportsOracleConsumer.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\r\n//import \"./mock/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * Request testnet LINK and ETH here: https://faucets.chain.link/\r\n * Find information on LINK Token Contracts and get the latest ETH and LINK faucets here: https://docs.chain.link/docs/link-token-contracts/\r\n */\r\n\r\nabstract contract SportsOracleConsumer is ChainlinkClient {\r\n    using Chainlink for Chainlink.Request;\r\n\r\n    address public immutable chainlink;\r\n    string public sportsOracleURI;\r\n\r\n    bytes32 private jobId;\r\n    uint256 private fee;\r\n\r\n    mapping(address => uint256) public userToLink;\r\n\r\n    event RequestedFixtureKickoff(bytes32 indexed requestId, string fixtureID);\r\n\r\n    event RequestedFixtureResult(bytes32 indexed requestId, string fixtureID);\r\n\r\n    event RequestFixtureKickoffFulfilled(\r\n        bytes32 indexed requestId,\r\n        string fixtureID,\r\n        uint256 kickoff\r\n    );\r\n\r\n    event RequestFixtureResultFulfilled(\r\n        bytes32 indexed requestId,\r\n        string fixtureID,\r\n        uint256 result\r\n    );\r\n\r\n    event RequestFixtureResultError(\r\n        bytes32 indexed requestId,\r\n        string error\r\n    );\r\n    \r\n    constructor(\r\n        string memory _sportsOracleURI,\r\n        address _oracle,\r\n        address _link,\r\n        string memory _jobId,\r\n        uint256 _fee\r\n    ) {\r\n        sportsOracleURI = _sportsOracleURI;\r\n        setChainlinkToken(_link);\r\n        setChainlinkOracle(_oracle);\r\n        chainlink = _oracle;\r\n        jobId = stringToBytes32(_jobId);\r\n        fee = _fee;\r\n    }\r\n\r\n    modifier hasLinkFee() {\r\n        require(userToLink[msg.sender] >= fee, \"You haven't sent enough LINK.\");\r\n        _;\r\n    }\r\n\r\n    function stringToBytes32(string memory source)\r\n        private\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n\r\n        assembly {\r\n            // solhint-disable-line no-inline-assembly\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Request fixture kickoff time from the oracle in a single transaction\r\n     */\r\n    function requestFixtureKickoffTimeParameter(string memory fixtureID)\r\n        public\r\n        hasLinkFee\r\n        returns (bytes32)\r\n    {\r\n        // User spends LINK value = fee on this request\r\n        userToLink[msg.sender] -= fee;\r\n\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobId,\r\n            address(this),\r\n            this.rawFulfillFixtureKickoffTime.selector\r\n        );\r\n        req.add(\"get\", string.concat(sportsOracleURI, fixtureID));\r\n        req.add(\"path\", \"0,ko\");\r\n        req.addInt(\"times\", 1);\r\n        return sendChainlinkRequest(req, fee); // MWR API.\r\n    }\r\n\r\n    function rawFulfillFixtureKickoffTime(bytes32 requestId, uint256 ko)\r\n        public\r\n        recordChainlinkFulfillment(requestId)\r\n    {\r\n        require(msg.sender == chainlink, \"Only ChainlinkClient can fulfill\");\r\n        fulfillFixtureKickoffTime(requestId, ko);\r\n    }\r\n\r\n    function fulfillFixtureKickoffTime(bytes32 requestId, uint256 ko)\r\n        internal\r\n        virtual;\r\n\r\n    /**\r\n     * @notice Request fixture result from the oracle in a single transaction\r\n     */\r\n    function requestFixtureResultParameter(string memory fixtureID)\r\n        public\r\n        hasLinkFee\r\n        returns (bytes32)\r\n    {\r\n        // User spends LINK value = fee on this request\r\n        userToLink[msg.sender] -= fee;\r\n\r\n        Chainlink.Request memory req = buildChainlinkRequest(\r\n            jobId,\r\n            address(this),\r\n            this.rawFulfillFixtureResult.selector\r\n        );\r\n        req.add(\"get\", string.concat(sportsOracleURI, fixtureID));\r\n        req.add(\"path\", \"0,result\");\r\n        req.addInt(\"times\", 1);\r\n        return sendChainlinkRequest(req, fee); // MWR API.\r\n    }\r\n\r\n    function rawFulfillFixtureResult(bytes32 requestId, uint256 result)\r\n        public\r\n        recordChainlinkFulfillment(requestId)\r\n    {\r\n        require(msg.sender == chainlink, \"Only ChainlinkClient can fulfill\");\r\n        fulfillFixtureResult(requestId, result);\r\n    }\r\n\r\n    function fulfillFixtureResult(bytes32 requestId, uint256 result)\r\n        internal\r\n        virtual;\r\n\r\n    // Anybody can transfer LINK to ctx\r\n    function transferLink(uint256 amount) public {\r\n        IERC20 link = IERC20(chainlinkTokenAddress());\r\n        require(\r\n            link.transferFrom(msg.sender, address(this), amount),\r\n            \"Unable to transfer\"\r\n        );\r\n\r\n        userToLink[msg.sender] += amount;\r\n    }\r\n\r\n    /**\r\n     * Allow withdraw of Link tokens from the contract\r\n     */\r\n    function withdrawLink(uint256 amount) public {\r\n        require(amount <= userToLink[msg.sender], \"You don't have enough link\");\r\n        userToLink[msg.sender] -= amount;\r\n\r\n        IERC20 link = IERC20(chainlinkTokenAddress());\r\n        require(link.transfer(msg.sender, amount), \"Unable to transfer\");\r\n    }\r\n}\r\n"
    },
    "contracts/SportsBettingLib.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.12;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nlibrary SportsBettingLib {\r\n    // Define DEFAULT FixtureResult = 0. \r\n    // DEFAULT FixtureResult is actually invalid and acts a placeholder to catch erroneous\r\n    // FixtureResult entries, as Solidity interprets null values as 0.\r\n    // CANCELLED FixtureResult allows us to handle cases where sports fixtures are cancelled\r\n    // and we should allow all stakers to withdraw their stakes\r\n    enum FixtureResult {\r\n        DEFAULT,\r\n        CANCELLED,\r\n        HOME,\r\n        DRAW,\r\n        AWAY\r\n    }\r\n\r\n    function getFixtureResultFromAPIResponse(\r\n        uint256 result\r\n    ) external pure returns (FixtureResult) {\r\n        if (result == uint256(FixtureResult.HOME)) {\r\n            return FixtureResult.HOME;\r\n        } else if (result == uint256(FixtureResult.DRAW)) {\r\n            return FixtureResult.DRAW;\r\n        } else if (result == uint256(FixtureResult.AWAY)) {\r\n            return FixtureResult.AWAY;\r\n        } else if (result == uint256(FixtureResult.CANCELLED)) {\r\n            return FixtureResult.CANCELLED;\r\n        }\r\n        return FixtureResult.DEFAULT;\r\n    }\r\n\r\n    function getLosingFixtureOutcomes(FixtureResult winningOutcome)\r\n        external\r\n        pure\r\n        returns (FixtureResult[] memory)\r\n    {\r\n        FixtureResult[] memory losingOutcomes = new FixtureResult[](2);\r\n\r\n        uint256 losingOutcomesIndex = 0;\r\n        for (uint256 i = uint256(FixtureResult.HOME); i <= uint256(FixtureResult.AWAY); i++) {\r\n            if (FixtureResult(i) != winningOutcome) {\r\n                losingOutcomes[losingOutcomesIndex] = FixtureResult(i);\r\n                losingOutcomesIndex += 1;\r\n            }\r\n        }\r\n        return losingOutcomes;\r\n    }\r\n\r\n    function calculateStakerObligation(\r\n        uint256 stakerAmount,\r\n        uint256 winningAmount,\r\n        uint256 totalAmount\r\n    ) public pure returns(uint256) {\r\n        bool flag;\r\n        uint256 stakerShare;\r\n        uint256 obligation;\r\n        (flag, stakerShare) = SafeMath.tryMul(totalAmount, stakerAmount);\r\n        if (!flag) {\r\n            revert(\"Overflow calculating obligation\");\r\n        }\r\n        (flag, obligation) = SafeMath.tryDiv(stakerShare, winningAmount);\r\n        if (!flag) {\r\n            revert(\"Division by zero\");\r\n        }\r\n        \r\n        return obligation;\r\n    }\r\n\r\n    function calculateCommission(\r\n        uint256 stakerObligation,\r\n        uint256 stakerAmount,\r\n        uint256 commissionRate\r\n    ) public pure returns(uint256) {\r\n        bool flag;\r\n        uint256 profit;\r\n        uint256 commission;\r\n        (flag, profit) = SafeMath.trySub(stakerObligation, stakerAmount);\r\n        if (!flag) {\r\n            revert(\"Underflow calculating profit\");\r\n        }\r\n        (flag, commission) = SafeMath.tryMul(commissionRate, profit);\r\n        if (!flag) {\r\n            revert(\"Overflow calculating commission\");\r\n        }\r\n        // Divide by 100 as COMMISSION_RATE is in percentage terms\r\n        return commission / 100;\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/test/SportsBettingTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.12;\r\n\r\nimport \"../SportsBetting.sol\";\r\nimport \"../SportsBettingLib.sol\";\r\n\r\ncontract SportsBettingTest is SportsBetting {\r\n    uint256 public linkFee;\r\n\r\n    constructor(\r\n        string memory _sportsOracleURI,\r\n        address _oracle,\r\n        address _dai,\r\n        address _link,\r\n        string memory _jobId,\r\n        uint256 _fee\r\n    )\r\n        SportsBetting(\r\n            _sportsOracleURI,\r\n            _oracle,\r\n            _dai,\r\n            _link,\r\n            _jobId,\r\n            _fee\r\n        )\r\n    {\r\n        linkFee = _fee;\r\n    }\r\n\r\n    function setCommissionPaidCheat(\r\n        string memory fixtureID,\r\n        bool wasPaid\r\n    ) public {\r\n        commissionPaid[fixtureID] = wasPaid;\r\n    }\r\n\r\n    function handleCommissionPayoutTest(\r\n        string memory fixtureID\r\n    ) public {\r\n        handleCommissionPayout(fixtureID);\r\n    }\r\n\r\n    function handleFixtureCancelledPayoutTest(\r\n        string memory fixtureID\r\n    ) public {\r\n        handleFixtureCancelledPayout(fixtureID);\r\n    }\r\n\r\n    function handleWithdrawPayoutTest(\r\n        string memory fixtureID\r\n    ) public {\r\n        handleWithdrawPayout(fixtureID);\r\n    }\r\n\r\n    function setFixtureResultCheat(\r\n        string memory fixtureID,\r\n        SportsBettingLib.FixtureResult result\r\n    ) public {\r\n        results[fixtureID] = result;\r\n    }\r\n\r\n    function setUserWasPaidCheat(\r\n        string memory fixtureID,\r\n        address user,\r\n        bool wasPaid\r\n    ) public {\r\n        userWasPaid[fixtureID][user] = wasPaid;\r\n    }\r\n\r\n    function setUserStakeCheat(\r\n        string memory fixtureID, \r\n        SportsBettingLib.FixtureResult betType,\r\n        address staker,\r\n        uint256 amount\r\n    ) public {\r\n        amounts[fixtureID][betType][staker] = amount;\r\n    }\r\n\r\n    function setTotalStakeCheat(\r\n        string memory fixtureID, \r\n        SportsBettingLib.FixtureResult betType,\r\n        uint256 amount\r\n    ) public {\r\n        totalAmounts[fixtureID][betType] = amount;\r\n    }\r\n\r\n    function setUserToLinkCheat(address addr, uint256 amount) public {\r\n        userToLink[addr] = amount;\r\n    }\r\n\r\n    function setRequestKickoffToFixtureCheat(bytes32 requestId, string memory fixtureId) public {\r\n        requestKickoffToFixture[requestId] = fixtureId;\r\n    }\r\n\r\n    function setRequestResultToFixtureCheat(bytes32 requestId, string memory fixtureId) public {\r\n        requestResultToFixture[requestId] = fixtureId;\r\n    }\r\n\r\n    function setFixtureBettingStateCheat(\r\n        string memory fixtureID,\r\n        BettingState state\r\n    ) public {\r\n        bettingState[fixtureID] = state;\r\n    }\r\n\r\n    function setFixtureKickoffTimeCheat(\r\n        string memory fixtureID,\r\n        uint256 ko\r\n    ) public {\r\n        fixtureToKickoffTime[fixtureID] = ko;\r\n    }\r\n\r\n    function getStakeSummaryForUserTest(string memory fixtureID, address user)\r\n        public\r\n        view\r\n        returns (uint256[3] memory)\r\n    {\r\n        return getStakeSummaryForUser(fixtureID, user);\r\n    }\r\n\r\n    // Wrapper for setting fixture betting state and emitting event\r\n    function setFixtureBettingStateTest(\r\n        string memory fixtureID,\r\n        BettingState state\r\n    ) public {\r\n        setFixtureBettingState(fixtureID, state);\r\n    }\r\n\r\n    /*function shouldHaveCorrectBettingStateTest(string memory fixtureID) public {\r\n        shouldHaveCorrectBettingState(fixtureID);\r\n    }*/\r\n\r\n    function fulfillFixtureKickoffTimeTest(bytes32 requestId, uint256 ko)\r\n        public\r\n    {\r\n        fulfillFixtureKickoffTime(requestId, ko);\r\n    }\r\n\r\n    function fulfillFixtureResultTest(bytes32 requestId, uint256 result) \r\n        public\r\n    {\r\n        fulfillFixtureResult(requestId, result);\r\n    }\r\n\r\n    function updateKickoffTimeTest(string memory fixtureID, uint256 ko)\r\n        public\r\n    {\r\n        updateKickoffTime(fixtureID, ko);\r\n    }\r\n\r\n    /*function fulfillFixturePayoutObligationsTest(\r\n        string memory fixtureID,\r\n        SportsBettingLib.BetType result,\r\n        uint256 winningAmount,\r\n        uint256 totalAmount\r\n    ) public {\r\n        fulfillFixturePayoutObligations(\r\n            fixtureID,\r\n            result,\r\n            winningAmount,\r\n            totalAmount\r\n        );\r\n    }*/\r\n\r\n    function getTotalAmountBetOnFixtureOutcomesTest(\r\n        string memory fixtureID,\r\n        SportsBettingLib.FixtureResult[] memory outcomes\r\n    ) public view returns (uint256) {\r\n        return getTotalAmountBetOnFixtureOutcomes(fixtureID, outcomes);\r\n    }\r\n\r\n    /*function updateFixtureResultTest(string memory fixtureID, uint256 _result)\r\n        public\r\n    {\r\n        updateFixtureResult(fixtureID, _result);\r\n    }*/\r\n}\r\n"
    },
    "contracts/test/SportsBettingLibTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.12;\r\n\r\nimport \"../SportsBettingLib.sol\";\r\n\r\ncontract SportsBettingLibTest {\r\n\r\n    function getFixtureResultFromAPIResponseTest(\r\n        uint256 result\r\n    ) public pure returns (SportsBettingLib.FixtureResult) {\r\n        return SportsBettingLib.getFixtureResultFromAPIResponse(result);\r\n    }\r\n\r\n    function getLosingFixtureOutcomesTest(SportsBettingLib.FixtureResult winningOutcome)\r\n        public\r\n        pure\r\n        returns (SportsBettingLib.FixtureResult[] memory)\r\n    {\r\n        return SportsBettingLib.getLosingFixtureOutcomes(winningOutcome);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}